---
title: "Stacked Bayesian Variational Auto-Encoders for RNAseq Data Analysis"
author: "Owen Leary & Mattia Pizzagalli"
date: "May 13, 2023"
output: md_document
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(include=FALSE)

library(knitr)
library(tidyverse)
library(scDHA)
library(mclust)
library(Rtsne)
library(microbenchmark)
library(cluster)
library(vegan)
library(clValid)


```


When analyzing large datasets, for example when thousands or more variables are reported per thousands or more observations, it is useful in terms of computational efficiency and building intuition around analysis results to reduce the “dimensions,” or the number of variables represented, within the data. Large datasets in which dimension reduction might be applied include population data with many individuals and many person-level variables per individual, such as large healthcare datasets, or single-cell gene expression datasets, such as might be generated by *single-cell RNA sequencing (scRNA-seq)* analysis – more on this later. In these and other examples, the mechanics of dimension reduction involve dropping variables which explain only a small proportion of the variance, or none of the variance, seen between observations within the data.

A widely used technique for applying dimension reduction when working with large datasets like those described above is called *Principal Component Analysis (PCA)*. By transforming datasets into a lower-dimensional space, PCA can help to simplify the data and extract its underlying structure. In particular, PCA seeks to identify the principal components that explain the maximum variance in the data. These principal components can be thought of as new variables that capture the most important information in the original data, each of which draws contribution from one or multiple of the variables from the original dataset. Applying PCA for dimension reduction can lead to interpretable clusters, which can help to reveal patterns and relationships that are not easily visible in the original data distilled into the magnitude of similarity and differences between observations mapped onto axes representing, for example, the first and second principal components (*Figure 1*). [1] In such examples, the principal components obtained through PCA are often easier to interpret than the original variables, as they represent linear combinations of the original variables that capture the most important information. This can be particularly useful for clustering analysis, as it can help to identify groups of similar observations based on their underlying characteristics.

```{r}

include_graphics("fig1.png")

```






```{r goolam, include=FALSE}

#set seed for reproducibility
set.seed(1)
#Example data Import and log transformation
data("Goolam")
data <- t(Goolam$data); label <- as.character(Goolam$label)

data <- log10(data + 1)

#Generate clustering result, the input matrix has rows as samples and columns as genes
result <- scDHA(data)

#The clustering result can be found here 
cluster <- result$cluster

#Calculate adjusted Rand Index using mclust package
ari <- round(mclust::adjustedRandIndex(cluster,label), 2)
print(paste0("ARI = ", ari))

#Visualization
plot_result <- scDHA.vis(result, method = "scDHA")

scDHAplot <- ggplot(data = as.data.frame(plot_result$pred)) + 
  geom_point(aes(x = V1, y = V2, color = factor(label), shape = factor(result$cluster))) + 
  labs(x = "scDHA1", y = "scDHA2", title = "scDHA Analysis of \n Goolam Data Set", color = "Mouse Embryo \n Stage", shape = "Cluster") +
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_text(hjust = 0.5))
  
scDHAplot

#Calculating the jaccard distance between subjects
distances <- vegdist(data, method = "jaccard")

#Silhouette plot
silhouette_scDHA <- function(k){
  # gets silhouette coefficient for particular k
  scDHA_clust <- scDHA(data, k = k, seed = 1)
  ss <- silhouette(scDHA_clust$cluster, dmatrix=as.matrix(distances))
  return(mean(ss[, 3]))
}

plot(2:7, sapply(2:7, silhouette_scDHA), type="b", main = "Silhouette Coefficient for scDHA \n Clustering of Data", ylab = "Silhouette Coefficient", xlab= "Number of Clusters")

#Dunn Index
dunn_scDHA <- function(k){
  # gets silhouette coefficient for particular k
  scDHA_clust <- scDHA(data, k = k, seed = 1)
  dunn_index <- dunn(scDHA_clust$cluster, distance = as.matrix(distances))
  return(dunn_index)
}

plot(2:7, sapply(2:7, dunn_scDHA), type="b", main = "Dunn Index for scDHA \n Clustering of Data", ylab = "Dunn Index", xlab= "Number of Clusters")

#Split data into training and testing sets
set.seed(1)
idx <- sample.int(nrow(data), size = round(nrow(data)*0.75))
train.x <- data[idx, ]; train.y <- label[idx]
test.x <- data[-idx, ]; test.y <- label[-idx]

#Predict the labels of cells in testing set, the input matrices have rows as samples and columns as genes
prediction <- scDHA.class(train = train.x, train.label = train.y, test = test.x, seed = 1)

#Calculate accuracy of the predictions
acc <- round(sum(test.y == prediction)/length(test.y), 2)
print(paste0("Accuracy = ", acc))


#tSNE dim red
tsne <- Rtsne(data, dims = 2)
tsne_data <- cbind(tsne$Y, label)
tsne_data <- as.data.frame(tsne_data)


tsne_plot <- ggplot(tsne_data) + 
  geom_point(aes(x = as.numeric(tsne_data[,1]), y = as.numeric(tsne_data[,2]), color = label)) + 
  labs(x = "", y = "", title = "tSNE Analysis of Goolam Data Set", color = "Mouse Embryo \n Stage") + 
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_text(hjust = 0.5))

tsne_plot


#PCA Analysis
PCA <- prcomp(data, scale = TRUE, retx = TRUE)
linear_dataset <- as.matrix(data) %*% PCA$rotation 
linear_dataset <- as.data.frame(linear_dataset) %>% cbind(label)

linear_plot <- ggplot(linear_dataset) + 
  geom_point(aes(x = PC1, y = PC2, color = label)) + 
  labs(x = "PC1", y = "PC2", title = "Linear PCA Analysis of \n Goolam Data Set", color = "Mouse Embryo \n Stage") +
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_text(hjust = 0.5))

linear_plot

#Scree plot
pca_linear_scree <- as.data.frame(PCA$sdev^2)
pca_linear_scree[,2] <- 1:nrow(pca_linear_scree)
colnames(pca_linear_scree) <- c("variance", "PCA")


pca_linear_scree <- pca_linear_scree %>% mutate(vari = variance / sum(variance), CumVar = cumsum(variance / sum(variance)))

linear_scree <- ggplot(pca_linear_scree, aes(y = CumVar, x = PCA)) + 
  geom_point() +
  geom_line() +
  theme_classic() +
  labs(x = "Component Number", y = "Proportion of variance explained", title = "Scree plot for linear PCA for \n Goolam Data Set") +
  theme(plot.title = element_text(hjust = 0.5), legend.title = element_text(hjust = 0.5))

linear_scree

#Speed Comparison. Look at User Time.
core10time <- system.time(scDHA(data, ncores = 10))
core1time <- system.time(scDHA(data, ncores = 1))
core10time
core1time

```

```{r hbsc, include=FALSE}

set.seed(1)

setwd("/Users/pizza/Library/CloudStorage/OneDrive-Personal/Brown Medical School/MDPHD/Classes/Spring2023/")

#Here I am loading in the data
rna_seq <- read_csv("rna_seq_data.csv")

#I am creating a separate variable that will carry the cell types of each sample. 
#However, in order to do the manipulations seen below I need to remove this character 
cell_type <- rna_seq$celltype
cell_type <- as.character(cell_type)

#Combining any cells that are CD4+ or CD8+ together
simple_celltype <- gsub("CD4\\+.*", "CD4+", cell_type)
simple_celltype <- gsub("CD8\\+.*", "CD8+", simple_celltype)

#Creating a new dataframe that only has the genes
genes_only <- rna_seq  %>% select(-32739) 

genes_only <- log10(genes_only + 1)

genes_only <- as.matrix(genes_only)

A2result <- scDHA(genes_only, seed = 1)

#The clustering result can be found here 
A2cluster <- A2result$cluster

#Visualization
A2plot_result <- scDHA.vis(A2result, seed = 1)


scDHAplotA2 <- ggplot(data = as.data.frame(A2plot_result$pred)) + 
  geom_point(aes(x = V1, y = V2, color = factor(cell_type))) + 
  labs(x = "scDHA1", y = "scDHA2", title = "scDHA Analysis of scRNAseq data \n from PBMCs", color = "Cell Type") +
  theme()


scDHAplotA2  
  
#Split data into training and testing sets
set.seed(1)
A2idx <- sample.int(nrow(genes_only), size = round(nrow(genes_only)*0.75))
A2train.x <- genes_only[A2idx, ]; A2train.y <- cell_type[A2idx]
A2test.x <- genes_only[-A2idx, ]; A2test.y <- cell_type[-A2idx]

A2train.x2 <- genes_only[A2idx, ]; A2train.y2 <- simple_celltype[A2idx]
A2test.x2 <- genes_only[-A2idx, ]; A2test.y2 <- simple_celltype[-A2idx]

#Predict the labels of cells in testing set, the input matrices have rows as samples and columns as genes
A2prediction <- scDHA.class(train = A2train.x, train.label = A2train.y, test = A2test.x, seed = 1)
A2prediction2 <- scDHA.class(train = A2train.x2, train.label = A2train.y2, test = A2test.x2, seed = 1)


#Calculate accuracy of the predictions
A2acc <- round(sum(A2test.y == A2prediction)/length(A2test.y), 2)
print(paste0("Accuracy with all cell types= ", A2acc))
A2acc2 <- round(sum(A2test.y2 == A2prediction2)/length(A2test.y2), 2)
print(paste0("Accuracy with CD4+ and CD8+ cells grouped= ", A2acc2))

#tSNE dim red
A2tsne <- Rtsne(genes_only, dims = 2)
A2tsne_data <- cbind(A2tsne$Y, cell_type)
A2tsne_data <- as.data.frame(A2tsne_data)

A2tsne_plot <- ggplot(A2tsne_data) + 
  geom_point(aes(x = as.numeric(A2tsne_data[,1]), y = as.numeric(A2tsne_data[,2]), color = cell_type)) + 
  labs(x = "", y = "", title = "tSNE Analysis of scRNAseq data \n from PBMCs", color = "Cell Type") + 
  theme()

A2tsne_plot


#PCA 
A2PCA <- prcomp(genes_only, retx = TRUE)
A2linear_dataset <- as.matrix(genes_only) %*% A2PCA$rotation
A2linear_dataset <- as.data.frame(A2linear_dataset) %>% cbind(cell_type)

linear_plotA2 <- ggplot(A2linear_dataset) + 
  geom_point(aes(x = PC1, y = PC2, color = cell_type)) + 
  labs(x = "PC1", y = "PC2", title = "Linear PCA Analysis of \n scRNAseq data from PBMCs", color = "Cell Type") +
  theme(plot.title = element_text(hjust = 0.5))

linear_plotA2

simple_linear_plotA2 <- ggplot(A2linear_dataset) + 
  geom_point(aes(x = PC1, y = PC2, color = simple_celltype)) + 
  labs(x = "PC1", y = "PC2", title = "Linear PCA Analysis of scRNAseq data \n from PBMCs", color = "Cell Type") +
  theme(plot.title = element_text(hjust = 0.5))

simple_linear_plotA2

#Scree plot
pca_linear_scree_A2 <- as.data.frame(A2PCA$sdev^2)
pca_linear_scree_A2[,2] <- 1:nrow(pca_linear_scree_A2)
colnames(pca_linear_scree_A2) <- c("variance", "PCA")


pca_linear_scree_A2 <- pca_linear_scree_A2 %>% mutate(vari = variance / sum(variance), CumVar = cumsum(variance / sum(variance)))

linear_scree_A2 <- ggplot(pca_linear_scree_A2, aes(y = CumVar, x = PCA)) + 
  geom_point() +
  geom_line() +
  theme_classic() +
  labs(x = "Component Number", y = "Proportion of variance explained", title = "Scree plot for linear PCA Analysis \n of scRNAseq data from PBMCs") +
  theme(plot.title = element_text(hjust = 0.5))

linear_scree_A2
linear_scree

```

\newpage
# Code Appendix
```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```
